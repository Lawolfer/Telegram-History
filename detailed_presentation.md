
# Образовательный бот по истории России
## Дипломная презентация проекта

### Содержание
1. [Введение и назначение проекта](#введение-и-назначение-проекта)
2. [Архитектура приложения](#архитектура-приложения)
3. [Компоненты системы](#компоненты-системы)
4. [Ключевая функциональность](#ключевая-функциональность)
5. [Взаимодействие с API Gemini](#взаимодействие-с-api-gemini)
6. [Обработка состояний и управление диалогом](#обработка-состояний-и-управление-диалогом)
7. [Административные функции](#административные-функции)
8. [Методы оптимизации и производительности](#методы-оптимизации-и-производительности)
9. [Безопасность](#безопасность)
10. [Масштабируемость и перспективы развития](#масштабируемость-и-перспективы-развития)
11. [Заключение](#заключение)

## Введение и назначение проекта

Образовательный бот по истории России представляет собой инновационный программный комплекс, разработанный для предоставления интерактивного, структурированного и удобного доступа к историческим знаниям. Проект создан с целью популяризации изучения истории России среди широкой аудитории пользователей мессенджера Telegram.

**Ключевые цели проекта:**
- Увеличение доступности качественной исторической информации
- Структурирование исторического материала по темам и главам
- Обеспечение интерактивной проверки знаний пользователя
- Поддержка непрерывного образовательного диалога через вопросно-ответную систему

Бот использует современные технологии искусственного интеллекта (Google Gemini) для генерации качественного образовательного контента и организации учебного процесса с адаптивным тестированием. Ключевой особенностью проекта является сочетание мощных возможностей ИИ с продуманной структурой подачи материала и удобным пользовательским интерфейсом.

## Архитектура приложения

Проект реализован в соответствии с модульной архитектурой, с четким разделением ответственности между компонентами. Архитектура построена по принципу MVC (Model-View-Controller) с адаптацией под специфику Telegram-бота.

**Структурная схема приложения:**

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Telegram API   │◄───►│    Bot Core     │◄───►│   Gemini API    │
└─────────────────┘     └─────────────────┘     └─────────────────┘
                               ▲
                               │
                 ┌─────────────┴─────────────┐
                 │                           │
        ┌────────▼────────┐        ┌────────▼────────┐
        │  CommandHandlers │        │  ContentService │
        └─────────────────┘        └─────────────────┘
                 ▲                           ▲
                 │                           │
      ┌──────────┴──────────┐     ┌─────────┴─────────┐
      │                     │     │                   │
┌─────▼─────┐         ┌────▼────┐ │ ┌───────────┐    │
│UIManager  │         │APIClient │ │ │APICache   │    │
└───────────┘         └─────────┘ │ └───────────┘    │
      ▲                    ▲      │       ▲          │
      │                    │      │       │          │
      └────────┬───────────┘      └───────┘          │
               │                                     │
        ┌──────▼──────┐                     ┌────────▼────────┐
        │MessageManager│                     │AdminPanel       │
        └─────────────┘                     └─────────────────┘
               ▲                                     ▲
               │                                     │
        ┌──────▼──────┐                     ┌────────▼────────┐
        │Logger       │                     │Config           │
        └─────────────┘                     └─────────────────┘
```

### Основные модули архитектуры:

1. **Bot Core** (`Bot`, `BotManager`): Центральные компоненты, ответственные за инициализацию бота, обработку команд и управление жизненным циклом приложения.

2. **Handlers** (`CommandHandlers`): Модуль обработки команд и взаимодействий пользователя с ботом, реализующий основную бизнес-логику.

3. **Services** (`ContentService`, `APIClient`): Сервисный слой для генерации контента и взаимодействия с внешними API.

4. **Managers** (`UIManager`, `MessageManager`): Компоненты для управления UI-элементами и контролем сообщений.

5. **Utility** (`APICache`, `Logger`, `Config`): Утилитарные модули для кэширования, логирования и конфигурации.

6. **Admin** (`AdminPanel`): Административный модуль для управления ботом и мониторинга.

Такая архитектура обеспечивает:
- Высокую модульность и возможность независимого тестирования компонентов
- Четкое разделение ответственности
- Простоту поддержки и расширения функциональности
- Устойчивость к сбоям за счет изоляции компонентов

## Компоненты системы

### 1. Модуль Bot (`src/bot.py`)

Класс `Bot` является ядром приложения и отвечает за:
- Инициализацию и настройку Telegram-бота
- Регистрацию обработчиков команд
- Управление состояниями диалога через `ConversationHandler`
- Параллельный запуск веб-сервера для мониторинга логов

```python
def setup(self):
    """Настройка бота и диспетчера"""
    try:
        # Инициализируем бота и диспетчер с оптимизированными настройками
        self.updater = Updater(self.config.telegram_token, use_context=True, workers=4)  # Увеличиваем количество рабочих потоков
        dp = self.updater.dispatcher

        # Создаем ConversationHandler для управления диалогом
        conv_handler = ConversationHandler(
            entry_points=[CommandHandler('start', self.handlers.start)],
            states={
                TOPIC: [
                    CallbackQueryHandler(self.handlers.button_handler)
                ],
                CHOOSE_TOPIC: [
                    CallbackQueryHandler(self.handlers.button_handler, pattern='^(more_topics|custom_topic|back_to_menu)$'),
                    CallbackQueryHandler(self.handlers.choose_topic, pattern='^topic_'),
                    MessageHandler(Filters.text & ~Filters.command, self.handlers.handle_custom_topic)
                ],
                # Другие состояния...
            },
            fallbacks=[CommandHandler('start', self.handlers.start)],
            allow_reentry=True
        )

        # Добавляем обработчики
        dp.add_error_handler(self.handlers.error_handler)
        dp.add_handler(conv_handler)
        
        # Добавляем обработчик для команды администратора
        dp.add_handler(CommandHandler('admin', self.handlers.admin_command))
        
        # Добавляем обработчик для обработки callback запросов администратора
        dp.add_handler(CallbackQueryHandler(self.handlers.admin_callback, pattern='^admin_'))

        return True
    except Exception as e:
        self.logger.log_error(e, "Ошибка при настройке бота")
        return False
```

Класс `BotManager` обеспечивает дополнительный уровень абстракции для управления запуском и остановкой бота.

### 2. Модуль CommandHandlers (`src/handlers.py`)

Класс `CommandHandlers` содержит логику обработки всех взаимодействий пользователя с ботом:
- Обработка команды /start и формирование приветственного сообщения
- Отображение меню и обработка нажатий на кнопки
- Логика выбора тем и генерации материалов
- Система тестирования и проверки ответов
- Режим беседы и интеллектуальная фильтрация запросов
- Обработка ошибок и административные функции

Пример метода для генерации и проведения тестирования:

```python
def handle_answer(self, update, context):
    """
    Обрабатывает ответы пользователя на вопросы теста.
    Args:
        update (telegram.Update): Объект обновления Telegram
        context (telegram.ext.CallbackContext): Контекст разговора
    Returns:
        int: Следующее состояние разговора
    """
    user_answer = update.message.text.strip()
    user_id = update.message.from_user.id

    # Очищаем историю чата
    self.message_manager.clear_chat_history(update, context)
    
    questions = context.user_data.get('questions', [])
    current_question = context.user_data.get('current_question', 0)

    # Проверка на наличие вопросов
    if not questions:
        self.logger.warning(f"Пользователь {user_id} пытается ответить на вопрос, но вопросы отсутствуют")
        update.message.reply_text(
            "Ошибка: вопросы не найдены. Начните тест заново.",
            reply_markup=self.ui_manager.main_menu()
        )
        return self.TOPIC

    # Получаем оригинальные вопросы и вопросы для отображения
    original_questions = context.user_data.get('original_questions', questions)
    display_questions = context.user_data.get('display_questions', questions)

    # Парсим правильный ответ из текста вопроса
    try:
        correct_answer_match = re.search(r"Правильный ответ:\s*(\d+)", original_questions[current_question])
        if correct_answer_match:
            correct_answer = correct_answer_match.group(1)
        else:
            raise ValueError("Формат правильного ответа не найден")
    except (IndexError, ValueError) as e:
        self.logger.error(f"Ошибка при обработке ответа пользователя {user_id}: {e}")
        update.message.reply_text(
            "Ошибка в формате вопросов. Попробуй начать тест заново.", 
            reply_markup=self.ui_manager.main_menu()
        )
        return self.TOPIC

    # Проверка ответа и начисление очков
    if user_answer == correct_answer:
        context.user_data['score'] = context.user_data.get('score', 0) + 1
        sent_msg = update.message.reply_text("✅ Правильно!")
        self.message_manager.save_message_id(update, context, sent_msg.message_id)
        self.logger.info(f"Пользователь {user_id} ответил верно на вопрос {current_question+1}")
    else:
        sent_msg = update.message.reply_text("❌ Неправильно!")
        self.message_manager.save_message_id(update, context, sent_msg.message_id)
        self.logger.info(f"Пользователь {user_id} ответил неверно на вопрос {current_question+1}")

    # Переходим к следующему вопросу
    context.user_data['current_question'] = current_question + 1

    # Проверка на завершение теста
    if context.user_data['current_question'] < len(display_questions):
        # Отображение следующего вопроса...
        return self.ANSWER
    else:
        # Подведение итогов тестирования
        score = context.user_data.get('score', 0)
        total_questions = len(questions)
        percentage = (score / total_questions) * 100

        # Анализ результатов и формирование оценки
        if percentage >= 90:
            assessment = "🏆 Отлично! Ты прекрасно усвоил материал."
        elif percentage >= 70:
            assessment = "👍 Хорошо! Ты неплохо усвоил материал, но есть над чем поработать."
        elif percentage >= 50:
            assessment = "👌 Удовлетворительно. Рекомендуется повторить материал."
        else:
            assessment = "📚 Неудовлетворительно. Тебе стоит изучить тему заново."

        update.message.reply_text(
            f"🎯 Тест завершен! Ты ответил правильно на {score} из {total_questions} вопросов ({percentage:.1f}%).\n\n{assessment}\n\n"
            "Выбери следующее действие:",
            reply_markup=self.ui_manager.main_menu()
        )
        self.logger.info(f"Пользователь {user_id} завершил тест с результатом {score}/{total_questions} ({percentage:.1f}%)")
        return self.TOPIC
```

### 3. Модуль ContentService (`src/content_service.py`)

Класс `ContentService` управляет генерацией и структурированием образовательного контента:
- Создание структурированной информации по темам
- Генерация тестовых вопросов и вариантов ответов
- Форматирование материала для удобного отображения в мессенджере

Этот модуль активно взаимодействует с API Gemini для создания качественного контента по истории России, используя продвинутые техники промптов для получения структурированных ответов.

### 4. Модуль UIManager (`src/ui_manager.py`)

Класс `UIManager` отвечает за формирование пользовательского интерфейса:
- Создание кнопок и инлайн-клавиатур
- Парсинг и форматирование тем
- Генерация адаптивных меню

### 5. Модуль MessageManager (`src/message_manager.py`)

Класс `MessageManager` реализует управление сообщениями в чате:
- Сохранение ID отправленных сообщений
- Очистка истории чата для улучшения пользовательского опыта
- Обработка ограничений Telegram API на удаление сообщений

### 6. Модуль APIClient (`src/api_client.py`)

Класс `APIClient` обеспечивает взаимодействие с Google Gemini API:
- Отправка запросов к AI-модели
- Обработка ответов и форматирование результатов
- Контроль параметров генерации (температура, длина ответа и др.)

### 7. Модуль APICache (`src/api_cache.py`)

Класс `APICache` реализует механизм кэширования запросов к API:
- Сохранение результатов частых запросов для снижения нагрузки
- Периодическое обновление кэша
- Контроль размера кэша и политики вытеснения

### 8. Модуль Logger (`src/logger.py`)

Класс `Logger` обеспечивает расширенное логирование работы бота:
- Запись событий разных уровней важности
- Ротация логов
- Форматирование сообщений об ошибках для упрощения отладки

### 9. Модуль Config (`src/config.py`)

Класс `Config` отвечает за конфигурацию приложения:
- Загрузка переменных окружения
- Валидация ключей API
- Хранение констант и состояний бота

### 10. Модуль AdminPanel (`src/admin_panel.py`)

Класс `AdminPanel` предоставляет административный интерфейс:
- Управление администраторами бота
- Мониторинг статистики использования
- Просмотр и фильтрация логов

## Ключевая функциональность

### 1. Система изучения тем

Функционал изучения тем реализован через несколько взаимосвязанных методов:
- `button_handler`: обработка нажатия на кнопку "Выбрать тему"
- `choose_topic`: обработка выбора темы из списка или ввода своей темы
- `handle_custom_topic`: обработка ввода пользовательской темы
- `get_topic_info`: запрос и структурирование информации по теме через API Gemini

Процесс генерации списка тем использует продвинутые промпты:

```python
prompt = "Составь список из 30 ключевых тем по истории России, которые могут быть интересны для изучения. Каждая тема должна быть емкой и конкретной (не более 6-7 слов). Перечисли их в виде нумерованного списка."
topics_text = self.api_client.ask_grok(prompt)
```

Каждая тема структурирована в 5 глав:
1. Введение и истоки
2. Основные события и развитие
3. Ключевые фигуры и реформы
4. Внешняя политика и влияние
5. Итоги и историческое значение

Такая структура обеспечивает последовательное и всестороннее изучение исторических периодов.

### 2. Система тестирования

Система тестирования включает:
- Генерацию уникальных вопросов по выбранной теме
- Создание вариантов ответов с одним правильным
- Проверку ответов пользователя и подсчет баллов
- Анализ результатов и формирование рекомендаций

Для генерации вопросов используется специализированный промпт:

```python
prompt = f"""Создай 15 тестовых вопросов по теме "{topic}" из истории России.
Для каждого вопроса сделай 4 варианта ответа, где только один правильный.
Формат каждого вопроса должен быть такой:

Вопрос: [текст вопроса]
1. [вариант 1]
2. [вариант 2]
3. [вариант 3]
4. [вариант 4]
Правильный ответ: [номер правильного ответа (1, 2, 3 или 4)]

Вопросы должны быть разного уровня сложности.
"""
```

После завершения теста система анализирует результаты и предоставляет пользователю персонализированную обратную связь на основе процента правильных ответов.

### 3. Система интеллектуальной беседы

Режим беседы реализован в методе `handle_conversation` и включает:
- Двухступенчатую проверку релевантности вопроса теме истории России
- Генерацию контекстуальных ответов на основе исторических фактов
- Интеллектуальную обработку неподходящих запросов с рекомендациями по переформулировке

```python
# Проверяем, относится ли сообщение к истории России
check_prompt = f"Проверь, относится ли следующее сообщение к истории России: \"{user_message}\". Ответь только 'да' или 'нет'."

is_history_related = self.api_client.ask_grok(check_prompt, max_tokens=50, temp=0.1).lower().strip()

if 'да' in is_history_related:
    # Генерация информативного ответа по истории
    prompt = f"Пользователь задал вопрос на тему истории России: \"{user_message}\"\n\n" \
            "Ответь на этот вопрос, опираясь на исторические факты. " \
            "Будь информативным, но кратким."
else:
    # Вежливый отказ с рекомендацией
    prompt = f"Пользователь задал вопрос не относящийся к истории России: \"{user_message}\"\n\n" \
            "Вежливо объясни, что ты специализируешься только на истории России, и " \
            "предложи задать вопрос, связанный с историей России. Приведи пример возможного вопроса."
```

Такой подход обеспечивает сфокусированное взаимодействие с пользователем в рамках исторической тематики.

## Взаимодействие с API Gemini

Взаимодействие с Google Gemini API реализовано через класс `APIClient` с оптимизацией для образовательных целей:

### Ключевые аспекты работы с API:

1. **Контроль параметров генерации**:
   - Низкая температура (0.1-0.3) для фактологических ответов
   - Более высокая температура (0.7) для генерации творческих тестовых заданий
   - Динамический контроль длины ответа в зависимости от типа запроса

```python
def ask_grok(self, prompt, max_tokens=1024, temp=0.3, use_cache=True):
    """
    Отправляет запрос к API Gemini и возвращает ответ.
    
    Args:
        prompt (str): Текст запроса
        max_tokens (int): Максимальное количество токенов в ответе
        temp (float): Температура генерации (0.0 - 1.0)
        use_cache (bool): Использовать ли кэширование
        
    Returns:
        str: Ответ от API Gemini
    """
    # Проверка кэша, если включено кэширование
    if use_cache:
        cached_response = self.cache.get(prompt)
        if cached_response:
            self.logger.info("Использован кэшированный ответ API")
            return cached_response
    
    # Формирование запроса
    api_url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent"
    headers = {
        "Content-Type": "application/json"
    }
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {
            "temperature": temp,
            "maxOutputTokens": max_tokens,
            "topP": 0.8,
            "topK": 40
        }
    }
    
    # Добавление API-ключа в URL
    api_url = f"{api_url}?key={self.api_key}"
    
    # Отправка запроса с повторными попытками
    response = None
    max_retries = 3
    retry_delay = 2
    
    for attempt in range(max_retries):
        try:
            response = requests.post(api_url, headers=headers, json=data, timeout=30)
            response.raise_for_status()  # Проверка статус-кода
            break
        except requests.exceptions.RequestException as e:
            self.logger.warning(f"Попытка {attempt+1}/{max_retries} не удалась: {e}")
            if attempt == max_retries - 1:
                self.logger.error(f"Не удалось получить ответ от API после {max_retries} попыток")
                raise
            time.sleep(retry_delay * (attempt + 1))  # Экспоненциальная задержка
    
    # Обработка ответа
    try:
        response_json = response.json()
        
        # Извлечение текста ответа
        if 'candidates' in response_json and len(response_json['candidates']) > 0:
            content = response_json['candidates'][0]['content']
            if 'parts' in content and len(content['parts']) > 0:
                answer = content['parts'][0]['text']
                
                # Кэшируем ответ, если кэширование включено
                if use_cache:
                    self.cache.add(prompt, answer)
                
                return answer
        
        # Если не удалось извлечь ответ
        self.logger.error(f"Неожиданный формат ответа API: {response_json}")
        return "Извините, произошла ошибка при обработке ответа от API."
    
    except Exception as e:
        self.logger.error(f"Ошибка при обработке ответа API: {e}")
        return "Извините, произошла ошибка при обработке ответа."
```

2. **Кэширование запросов**:
   - Сохранение результатов частых запросов в кэше
   - LRU-политика вытеснения для оптимизации памяти
   - Асинхронное сохранение кэша в файл

3. **Обработка ошибок API**:
   - Система повторных попыток с экспоненциальной задержкой
   - Детальное логирование ошибок
   - Информативные сообщения для пользователя в случае сбоев

## Обработка состояний и управление диалогом

Система управления диалогом реализована через `ConversationHandler` библиотеки `python-telegram-bot` с пятью основными состояниями:

1. **TOPIC**: Начальное состояние, отображение главного меню
2. **CHOOSE_TOPIC**: Выбор или ввод темы для изучения
3. **TEST**: Переходное состояние для генерации теста
4. **ANSWER**: Обработка ответов пользователя в режиме тестирования
5. **CONVERSATION**: Режим беседы о истории России

```python
conv_handler = ConversationHandler(
    entry_points=[CommandHandler('start', self.handlers.start)],
    states={
        TOPIC: [
            CallbackQueryHandler(self.handlers.button_handler)
        ],
        CHOOSE_TOPIC: [
            CallbackQueryHandler(self.handlers.button_handler, pattern='^(more_topics|custom_topic|back_to_menu)$'),
            CallbackQueryHandler(self.handlers.choose_topic, pattern='^topic_'),
            MessageHandler(Filters.text & ~Filters.command, self.handlers.handle_custom_topic)
        ],
        TEST: [
            CallbackQueryHandler(self.handlers.button_handler)
        ],
        ANSWER: [
            MessageHandler(Filters.text & ~Filters.command, self.handlers.handle_answer),
            CallbackQueryHandler(self.handlers.button_handler)
        ],
        CONVERSATION: [
            MessageHandler(Filters.text & ~Filters.command, self.handlers.handle_conversation),
            CallbackQueryHandler(self.handlers.button_handler)
        ]
    },
    fallbacks=[CommandHandler('start', self.handlers.start)],
    allow_reentry=True
)
```

Такая организация обеспечивает:
- Четкое управление переходами между режимами
- Сохранение контекста пользовательской сессии
- Возможность вернуться к начальному состоянию в любой момент
- Избежание конфликтов между различными режимами работы бота

## Административные функции

Административный модуль (`AdminPanel`) предоставляет набор функций для управления ботом:

1. **Управление администраторами**:
   - Добавление и удаление администраторов бота
   - Разделение на обычных админов и суперадминов с расширенными правами

2. **Мониторинг работы**:
   - Просмотр активных пользователей
   - Статистика использования различных функций
   - Анализ ошибок и проблемных ситуаций

3. **Управление логами**:
   - Просмотр и фильтрация системных логов
   - Экспорт логов для детального анализа
   - Настройка уровней логирования

Доступ к админ-панели осуществляется через команду `/admin` и проверку ID пользователя на наличие в списке администраторов (файл `admins.json`).

## Методы оптимизации и производительности

В проекте реализован ряд оптимизаций для обеспечения эффективной работы бота:

1. **Кэширование API-запросов**:
   - Снижение нагрузки на внешнее API
   - Ускорение ответов на частые запросы
   - Экономия ресурсов и API-квоты

2. **Многопоточная обработка**:
   - Использование нескольких рабочих потоков для обработки запросов (`workers=4`)
   - Асинхронное сохранение кэша и логов
   - Параллельный запуск веб-сервера для мониторинга

3. **Оптимизация памяти**:
   - Очистка истории сообщений для освобождения ресурсов
   - Контроль размера кэша с политикой LRU
   - Ротация логов для предотвращения переполнения хранилища

4. **Оптимизация запросов к ИИ**:
   - Двухступенчатая проверка релевантности
   - Дифференцированное использование токенов в зависимости от типа запроса
   - Разделение сложных промптов на более простые компоненты

## Безопасность

Система реализует многоуровневый подход к безопасности:

1. **Защита API-ключей**:
   - Хранение ключей в переменных окружения
   - Валидация ключей при запуске
   - Отсутствие жестко закодированных ключей в исходном коде

2. **Защита от атак**:
   - Фильтрация входящих сообщений
   - Ограничение доступа к административным функциям
   - Проверка прав доступа для критических операций

3. **Защита пользовательских данных**:
   - Минимизация хранимой информации о пользователях
   - Хранение контекста только в рамках текущей сессии
   - Отсутствие долгосрочного хранения личных данных

4. **Защита от мусорных запросов**:
   - Тематическая фильтрация сообщений
   - Проверка релевантности запросов перед отправкой в API
   - Корректные отказы для нерелевантных запросов

## Масштабируемость и перспективы развития

Проект спроектирован с учетом возможного масштабирования и развития:

1. **Архитектурная масштабируемость**:
   - Модульная структура позволяет легко добавлять новые функции
   - Четкое разделение ответственности упрощает внесение изменений
   - Абстракции для взаимодействия с внешними API

2. **Функциональная масштабируемость**:
   - Возможность добавления новых образовательных режимов
   - Интеграция дополнительных форматов контента (видео, аудио)
   - Расширение административных возможностей

3. **Перспективы развития**:
   - Добавление системы персонализированных рекомендаций
   - Реализация адаптивного обучения с учетом прогресса пользователя
   - Интеграция с образовательными платформами
   - Расширение языковой поддержки
   - Добавление интерактивных исторических карт и временных линий

## Заключение

Образовательный бот по истории России представляет собой комплексное решение для интерактивного изучения истории с использованием современных технологий искусственного интеллекта. Бот решает важную образовательную задачу, делая исторические знания более доступными и структурированными.

Ключевые достижения проекта:
- Создана эффективная архитектура с четким разделением ответственности
- Реализован интуитивно понятный пользовательский интерфейс
- Интегрирована мощная система генерации образовательного контента
- Разработан интерактивный механизм тестирования знаний
- Обеспечена высокая надежность и безопасность работы

Образовательный бот демонстрирует, как современные технологии ИИ могут быть эффективно применены в сфере образования для создания доступных, интерактивных и качественных обучающих инструментов.

---

© 2025 Образовательный бот по истории России
