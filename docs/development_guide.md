
# Руководство по разработке

## Содержание

1. [Обзор архитектуры](#обзор-архитектуры)
2. [Рабочий процесс разработки](#рабочий-процесс-разработки)
3. [Создание новых компонентов](#создание-новых-компонентов)
4. [Стиль кода](#стиль-кода)
5. [Обработка ошибок](#обработка-ошибок)
6. [Советы по производительности](#советы-по-производительности)
7. [Работа с API](#работа-с-api)
8. [Интеграция новых функций](#интеграция-новых-функций)

## Обзор архитектуры

Проект построен с использованием модульной архитектуры, основанной на паттернах Factory, Service Locator и Dependency Injection. Основные компоненты системы:

1. **Слой представления** (UI):
   - Bot Core
   - Command Handlers
   - UI Manager
   - Message Manager

2. **Слой бизнес-логики**:
   - Content Service
   - Test Service
   - Topic Service
   - Conversation Service
   - Analytics Service

3. **Слой данных**:
   - API Client
   - API Cache
   - Text Cache Service

4. **Инфраструктурный слой**:
   - Logger
   - Service Container
   - State Manager
   - Task Queue

## Рабочий процесс разработки

### 1. Ветвление и интеграция

Рекомендуется использовать следующую модель ветвления:

- `main` - стабильная ветка для релизов
- `dev` - ветка разработки
- `feature/название-функции` - ветки для новых функций
- `bugfix/название-ошибки` - ветки для исправления ошибок

### 2. Внесение изменений

1. Создайте новую ветку от `dev`
2. Внесите изменения, соблюдая стиль кода
3. Добавьте тесты для новой функциональности
4. Проверьте, что все тесты проходят
5. Создайте pull request в `dev`

### 3. Код-ревью

Все изменения должны пройти код-ревью перед слиянием. Обратите внимание на:
- Соответствие стилю кода
- Наличие тестов для новой функциональности
- Документацию к новым методам и классам
- Производительность и потенциальные улучшения

## Создание новых компонентов

### 1. Создание нового сервиса

```python
from src.base_service import BaseService
from src.interfaces import ILogger

class NewService(BaseService):
    """
    Описание функциональности нового сервиса.
    """
    
    def __init__(self, logger: ILogger, dependency1, dependency2):
        """
        Инициализация сервиса.
        
        Args:
            logger (ILogger): Логгер для записи сообщений
            dependency1: Первая зависимость
            dependency2: Вторая зависимость
        """
        super().__init__(logger)
        self.dependency1 = dependency1
        self.dependency2 = dependency2
    
    def _do_initialize(self) -> bool:
        """
        Выполняет фактическую инициализацию сервиса.
        
        Returns:
            bool: True если инициализация прошла успешно, иначе False
        """
        try:
            # Инициализация сервиса
            self._logger.info("NewService успешно инициализирован")
            return True
        except Exception as e:
            self._logger.error(f"Ошибка при инициализации NewService: {e}")
            return False
    
    def public_method(self, param1, param2):
        """
        Публичный метод сервиса.
        
        Args:
            param1: Первый параметр
            param2: Второй параметр
            
        Returns:
            Результат обработки
        """
        try:
            # Реализация метода
            return result
        except Exception as e:
            self._logger.error(f"Ошибка в public_method: {e}")
            # Обработка ошибки
```

### 2. Регистрация нового сервиса в фабрике

```python
# В файле src/factory.py

def create_new_service(container):
    """
    Создает и настраивает новый сервис.
    
    Args:
        container: Контейнер сервисов
        
    Returns:
        NewService: Настроенный экземпляр нового сервиса
    """
    logger = container.get_service('logger')
    dependency1 = container.get_service('dependency1')
    dependency2 = container.get_service('dependency2')
    
    new_service = NewService(logger, dependency1, dependency2)
    new_service.initialize()
    
    return new_service

# В методе create_services
def create_services(container):
    # ...
    
    # Создание и регистрация нового сервиса
    new_service = create_new_service(container)
    container.register_service('new_service', new_service)
    
    # ...
```

### 3. Создание нового обработчика команд

```python
# В файле src/handlers.py

def handle_new_command(update, context):
    """
    Обработчик новой команды.
    
    Args:
        update (telegram.Update): Объект обновления Telegram
        context (telegram.ext.CallbackContext): Контекст разговора
        
    Returns:
        int: Следующее состояние диалога
    """
    user_id = update.message.from_user.id
    
    # Получение необходимых сервисов из контейнера
    new_service = context.bot_data['container'].get_service('new_service')
    ui_manager = context.bot_data['container'].get_service('ui_manager')
    
    # Логика обработки команды
    result = new_service.public_method(param1, param2)
    
    # Формирование ответа пользователю
    keyboard = ui_manager.create_keyboard_for_new_command()
    update.message.reply_text(
        "Текст ответа на команду",
        reply_markup=keyboard
    )
    
    # Возвращение следующего состояния
    return NEW_COMMAND_STATE

# В файле src/bot.py, метод setup_bot
def setup_bot(self):
    # ...
    
    # Регистрация нового обработчика команд
    self.dispatcher.add_handler(CommandHandler('new_command', handle_new_command))
    
    # ...
```

## Стиль кода

Проект следует стандартам PEP 8 для стиля кода Python с некоторыми дополнениями:

1. **Именование**:
   - Классы: CamelCase (`class ServiceContainer:`)
   - Методы и функции: snake_case (`def get_service():`)
   - Константы: UPPER_CASE (`MAX_CACHE_SIZE = 1000`)
   - Приватные методы: с префиксом underscore (`def _do_initialize():`)

2. **Строки документации**:
   - Используйте docstrings в формате Google для всех публичных методов и классов
   - Включайте описание, параметры, возвращаемые значения и исключения

3. **Импорты**:
   - Группируйте импорты по следующим категориям:
     1. Стандартные библиотеки
     2. Сторонние библиотеки
     3. Импорты из проекта
   - Сортируйте импорты в алфавитном порядке внутри каждой группы

4. **Длина строки**: Ограничивайте длину строки до 100 символов

## Обработка ошибок

1. **Принципы обработки ошибок**:
   - Перехватывайте только ожидаемые исключения
   - Логируйте все исключения с контекстом
   - Используйте конкретные типы исключений вместо общих
   - Не подавляйте исключения без обработки

2. **Пример правильной обработки ошибок**:

```python
def process_data(data):
    try:
        # Обработка данных
        result = perform_operation(data)
        return result
    except ValueError as e:
        # Конкретная обработка ошибки формата данных
        self._logger.error(f"Ошибка формата данных: {e}")
        return None
    except ConnectionError as e:
        # Обработка ошибки подключения
        self._logger.error(f"Ошибка подключения: {e}")
        raise  # Пробрасываем дальше, так как это критическая ошибка
    except Exception as e:
        # Отлов непредвиденных ошибок для логирования
        self._logger.error(f"Непредвиденная ошибка при обработке данных: {e}")
        self._logger.debug(f"Стек вызовов: {traceback.format_exc()}")
        return None
```

## Советы по производительности

1. **Оптимизация запросов к API**:
   - Используйте кэширование для часто запрашиваемых данных
   - Ограничивайте частоту запросов
   - Используйте асинхронные запросы для параллельной обработки

2. **Обработка больших объемов данных**:
   - Используйте пагинацию для больших списков
   - Загружайте данные по требованию, а не все сразу
   - Используйте генераторы вместо списков для обработки последовательностей

3. **Управление памятью**:
   - Освобождайте ресурсы после использования
   - Используйте контекстные менеджеры (`with`) для автоматического освобождения
   - Избегайте глобальных переменных и циклических ссылок

## Работа с API

1. **Gemini API**:
   - Документация по работе с API доступна в файле `docs/api_components.md`
   - Используйте класс APIClient из `src/api_client.py` для взаимодействия
   - Настраивайте параметры запросов в зависимости от задачи:
     - Низкая temperature (0.1-0.3) для фактической точности
     - Средняя temperature (0.4-0.7) для креативных ответов
     - Высокое top_p (0.9+) для разнообразия ответов

2. **Пример использования API**:

```python
def get_historical_info(topic):
    # Получение API клиента из контейнера
    api_client = container.get_service('api_client')
    
    # Формирование промпта с учетом рекомендаций
    prompt = f"""
    Предоставь точную историческую информацию о следующей теме из истории России: "{topic}".
    Ответ должен быть структурирован по разделам: хронология, участники, события, причины, последствия.
    """
    
    # Вызов API с оптимальными параметрами для исторических фактов
    result = api_client.call_api(
        prompt=prompt,
        temperature=0.2,
        max_tokens=1024,
        use_cache=True
    )
    
    return result.get("text", "")
```

## Интеграция новых функций

1. **Планирование**:
   - Определите требования к новой функции
   - Продумайте интеграцию с существующими компонентами
   - Спроектируйте необходимые изменения в интерфейсах

2. **Реализация**:
   - Создайте необходимые классы и методы
   - Интегрируйте с существующими сервисами через DI
   - Добавьте обработчики команд и колбэков

3. **Тестирование**:
   - Напишите модульные тесты для новой функциональности
   - Проверьте взаимодействие с существующими компонентами
   - Протестируйте пользовательские сценарии

4. **Документация**:
   - Обновите существующую документацию
   - Добавьте описание новой функциональности
   - Обновите примеры использования
